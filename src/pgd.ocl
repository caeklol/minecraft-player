#define TS 16

__kernel void gemm_whv(
	__global const float* w,      // m x r
	__global const float* h,      // r x n
	__global const float* v,  	  // m x n
	__global float* whv,          // m x n
	uint m, uint n, uint r
) {
	int row = get_global_id(0);
	int col = get_global_id(1);
	float sum = 0.0;
	for (uint k = 0; k < r; k++) {
		sum += w[row * r + k] * h[k * n + col];
	}
	whv[row * n + col] = sum - v[row * n + col];
}

__kernel void gemm_grad(
	__global const float* w_t,     // r x m
	__global const float* whv,     // m x n
	__global float* grad,          // r x n
	uint r, uint n, uint m
) {
	//int row = get_global_id(0);
	//int col = get_global_id(1);
	const int row = get_local_id(0);
    const int col = get_local_id(1);
    const int globalRow = TS*get_group_id(0) + row;
    const int globalCol = TS*get_group_id(1) + col;

	float sum = 0.0;

	__local float w_tsub[TS][TS];
	__local float whvsub[TS][TS];

	const int numTiles = (m + TS - 1) / TS;
	for (int t = 0; t < numTiles; t++) {
		const int tiledRow = TS*t + row;
		const int tiledCol = TS*t + col;

		if (globalRow < r && tiledCol < m) {
            w_tsub[row][col] = w_t[globalRow * m + tiledCol];
        } else {
            w_tsub[row][col] = 0.0f;
        }

        if (tiledRow < m && globalCol < n) {
            whvsub[row][col] = whv[tiledRow * n + globalCol];
        } else {
            whvsub[row][col] = 0.0f;
        }


		barrier(CLK_LOCAL_MEM_FENCE);

		for (int k = 0; k < TS; k++) {
			// no bounds check because 0*0 = 0
			sum += w_tsub[row][k] * whvsub[k][col];
		}

		barrier(CLK_LOCAL_MEM_FENCE);
	}

	if (globalRow < r && globalCol < n) {
		grad[globalRow * n + globalCol] = sum;
	}
}

__kernel void update_h(
	__global float* h,
	__global const float* grad,
	float step,
	uint r, uint n
) {
	int row = get_global_id(0);
	int col = get_global_id(1);
	float new_val = h[row * n + col] - grad[row * n + col] * step;
	h[row * n + col] = fmax(new_val, 0.0f);
}

#define TS_ROW 32
#define TS_COL 8

__kernel void gemm_whv(
	__global const float* w,      // m x r
	__global const float* h,      // r x n
	__global const float* v,  	  // m x n
	__global float* whv,          // m x n
	uint m, uint n, uint r
) {
	//int row = get_global_id(0);
	//int col = get_global_id(1);
	//float sum = 0.0;
	//for (uint k = 0; k < r; k++) {
	//	sum += w[row * r + k] * h[k * n + col];
	//}
	//whv[row * n + col] = sum - v[row * n + col];

	const int row = get_local_id(0);
    const int col = get_local_id(1);
    const int globalRow = TS_ROW*get_group_id(0) + row;
    const int globalCol = TS_COL*get_group_id(1) + col;

	float sum = 0.0;

	__local float wsub[TS_ROW][TS_COL];
	__local float hsub[TS_ROW][TS_COL];

	const int numTiles = (r + TS_COL - 1) / TS_COL;
	for (int t = 0; t < numTiles; t++) {
		const int tiledRow = TS_COL*t + row;
		const int tiledCol = TS_COL*t + col;

		if (globalRow < m && tiledCol < r) {
            wsub[row][col] = w[globalRow * r + tiledCol];
        } else {
            wsub[row][col] = 0.0f;
        }

        if (tiledRow < r && globalCol < n) {
            hsub[row][col] = h[tiledRow * n + globalCol];
        } else {
            hsub[row][col] = 0.0f;
        }


		barrier(CLK_LOCAL_MEM_FENCE);

		for (int k = 0; k < TS_COL; k++) {
			// no bounds check because 0*0 = 0
			sum += wsub[row][k] * hsub[k][col];
		}

		barrier(CLK_LOCAL_MEM_FENCE);
	}

	if (globalRow < m && globalCol < n) {
		int idx = globalRow * n + globalCol;
		whv[idx] = sum - v[idx];
	}
}

__kernel void gemm_grad(
	__global const float* w_t,     // r x m
	__global const float* whv,     // m x n
	__global float* grad,          // r x n
	uint r, uint n, uint m
) {
	//int row = get_global_id(0);
	//int col = get_global_id(1);
	const int row = get_local_id(0);
    const int col = get_local_id(1);
    const int globalRow = TS_ROW*get_group_id(0) + row;
    const int globalCol = TS_COL*get_group_id(1) + col;

	float sum = 0.0;

	__local float w_tsub[TS_ROW][TS_COL];
	__local float whvsub[TS_ROW][TS_COL];

	const int numTiles = (m + TS_COL - 1) / TS_COL;
	for (int t = 0; t < numTiles; t++) {
		const int tiledCol = TS_COL * t + col;
		const int tiledRow = TS_COL * t + row;

		if (globalRow < r && tiledCol < m) {
            w_tsub[row][col] = w_t[globalRow * m + tiledCol];
        } else {
            w_tsub[row][col] = 0.0f;
        }

        if (tiledRow < m && globalCol < n) {
            whvsub[row][col] = whv[tiledRow * n + globalCol];
        } else {
            whvsub[row][col] = 0.0f;
        }


		barrier(CLK_LOCAL_MEM_FENCE);

		for (int k = 0; k < TS_COL; k++) {
			// no bounds check because 0*0 = 0
			sum += w_tsub[row][k] * whvsub[k][col];
		}

		barrier(CLK_LOCAL_MEM_FENCE);
	}

	if (globalRow < r && globalCol < n) {
		grad[globalRow * n + globalCol] = sum;
	}
}

__kernel void update_h(
	__global float* h,
	__global const float* grad,
	float step,
	uint r, uint n
) {
	int row = get_global_id(0);
	int col = get_global_id(1);
	float new_val = h[row * n + col] - grad[row * n + col] * step;
	h[row * n + col] = fmax(new_val, 0.0f);
}

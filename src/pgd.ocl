#define TS_ROW 32 /// REPLACE_WITH_ROW
#define TS_COL 8 /// REPLACE_WITH_COL

__kernel void gemm_whv(
	__global const float* w,      // m x r
	__global const float* h,      // r x n
	__global const float* v,  	  // m x n
	__global float* whv,          // m x n
	uint m, uint n, uint r
) {
	//int row = get_global_id(0);
	//int col = get_global_id(1);
	//float sum = 0.0;
	//for (uint k = 0; k < r; k++) {
	//	sum += w[row * r + k] * h[k * n + col];
	//}
	//whv[row * n + col] = sum - v[row * n + col];

	const int row = get_local_id(0);
    const int col = get_local_id(1);
    const int globalRow = TS_ROW*get_group_id(0) + row;
    const int globalCol = TS_COL*get_group_id(1) + col;

	float sum = 0.0;

	__local float wsub[TS_ROW][TS_COL];
	__local float hsub[TS_COL][TS_COL];

	const int numTiles = (r + TS_COL - 1) / TS_COL;
	for (int t = 0; t < numTiles; t++) {
		const int tiledRow = TS_COL*t + row;
		const int tiledCol = TS_COL*t + col;

		if (globalRow < m && tiledCol < r) {
            wsub[row][col] = w[globalRow * r + tiledCol];
        } else {
            wsub[row][col] = 0.0f;
        }

		for (int i = row; i < TS_COL; i += TS_ROW) {
			int hRow = TS_COL * t + i;
			if (hRow < r && globalCol < n) {
				hsub[i][col] = h[hRow * n + globalCol];
			} else {
				hsub[i][col] = 0.0f;
			}
		}

		barrier(CLK_LOCAL_MEM_FENCE);

		for (int k = 0; k < TS_COL; k++) {
			// no bounds check because 0*0 = 0
			sum += wsub[row][k] * hsub[k][col];
		}

		barrier(CLK_LOCAL_MEM_FENCE);
	}

	if (globalRow < m && globalCol < n) {
		int idx = globalRow * n + globalCol;
		whv[idx] = sum - v[idx];
	}
}

__kernel void gemm_grad(
	__global const float* w_t,     // r x m
	__global const float* whv,     // m x n
	__global float* grad,          // r x n
	uint r, uint n, uint m
) {
	//int row = get_global_id(0);
	//int col = get_global_id(1);
	const int row = get_local_id(0);
    const int col = get_local_id(1);
    const int globalRow = TS_ROW*get_group_id(0) + row;
    const int globalCol = TS_COL*get_group_id(1) + col;

	float sum = 0.0;

	__local float w_tsub[TS_ROW][TS_COL];
	__local float whvsub[TS_COL][TS_COL];

	const int numTiles = (m + TS_COL - 1) / TS_COL;
	for (int t = 0; t < numTiles; t++) {
		const int tiledCol = TS_COL * t + col;
		const int tiledRow = TS_COL * t + row;

		if (globalRow < r && tiledCol < m) {
            w_tsub[row][col] = w_t[globalRow * m + tiledCol];
        } else {
            w_tsub[row][col] = 0.0f;
        }
		
		for (int i = row; i < TS_COL; i += TS_ROW) {
			int wvRow = TS_COL * t + i;
			if (wvRow < m && globalCol < n) {
				whvsub[i][col] = whv[wvRow * n + globalCol];
			} else {
				whvsub[i][col] = 0.0f;
			}
		}

		barrier(CLK_LOCAL_MEM_FENCE);

		for (int k = 0; k < TS_COL; k++) {
			// no bounds check because 0*0 = 0
			sum += w_tsub[row][k] * whvsub[k][col];
		}

		barrier(CLK_LOCAL_MEM_FENCE);
	}

	if (globalRow < r && globalCol < n) {
		grad[globalRow * n + globalCol] = sum;
	}
}

__kernel void update_h(
	__global float* h,
	__global const float* grad,
	float step,
	uint r, uint n
) {
	int row = get_global_id(0);
	int col = get_global_id(1);
	float new_val = h[row * n + col] - grad[row * n + col] * step;
	h[row * n + col] = fmax(new_val, 0.0f);
}
